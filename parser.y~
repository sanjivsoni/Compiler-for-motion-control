%{
<<<<<<< HEAD
  
  #include<stdio.h>
  #include<stdlib.h>
  #include<string>
  using namespace std;

  // Stuff from flex that bison needs to know about
  extern "C" int yylex();
  extern "C" int yyparse();
  extern "C" FILE *yyin;

  void yyerror(const char*s);
=======
#include "declaration.h"
#include<stdio.h>
int yylex();
void yyerror(const char *s);
>>>>>>> origin/master
%}


// define termminal symbols.
%token ROWS COLUMNS EQUALS START END OBSTACLE NUMBER COORDINATE

// bison gets next token from flex as 'yystype'
// Each type of token flex could return
// yacc will typedef 'yystype' as union instead of int(default)
%union
{
    int intValue;
    char charValue;
    char* stringValue;
}

<<<<<<< HEAD
// Associate each of the terminal tokens with one of union fields.
%type <stringValue> NUMBER COORDINATE ROWS COLUMNS START END
=======
%token <digit> INTEGER
%token ROWS
%token COLUMNS
%token COLON
%token START
%token END
%token OBSTACLE
%token COMMENT
%token ERROR
%token<id> POINT

>>>>>>> origin/master

// Define the starting production
%start PARSETREE

%%
// First rule is the hishest level rule


PARSETREE           :   LINES                                       {printf("P -> LS");}
                    ;

LINES               :   LINES LINE                                  {printf("LS -> LS L");}
                    |   LINE                                        {printf("LS -> L");}

LINE                :   ASSIGN_INT                                  {printf("P -> AI\n");}
                    |   ASSIGN_COORDINATE                           {printf("P -> AC\n");}
                    |   ASSIGN_OBSTACLE                             {printf("P -> AO\n");}
                    ;

ASSIGN_INT          :   ROWS EQUALS NUMBER                          {printf("AI -> R=N %d  %s \n",$1,$3);}
                    |   COLUMNS EQUALS NUMBER                       {printf("AI -> C=N\n");}
                    ;

ASSIGN_COORDINATE   :   START EQUALS COORDINATE                     {printf("AC -> S=C\n");}
                    |   END EQUALS COORDINATE                       {printf("AC -> E=C\n");}
                    ;

ASSIGN_OBSTACLE     :   OBSTACLE EQUALS HINDERENCES                 {printf("AO -> O=HS\n");}
                    ;

HINDERENCES         :   HINDERENCES HINDERENCE                      {printf("HS -> HS H\n");}
                    |   HINDERENCE                                  {printf("HS -> H\n");}

HINDERENCE          :   COORDINATE                                  {printf("H -> C\n");}

<<<<<<< HEAD

%%

void yyerror(const char* s)
=======
ASSIGNMENT      :   START   ':' POINT       {printf(" S -> P \n")}
                |   END     ':' POINT       {printf(" E -> P \n")};
                |   ROWS    ':' INTEGER     {printf(" R -> I \n")}
                |   COLUMNS ':' INTEGER     {printf(" C -> I \n")};
                ;

%%

int main(void)
>>>>>>> origin/master
{
    printf("Parse Error Message: %s\n",s);
}

int main(int argc, char**argv)
{
    if(argc != 2)
    {
        printf("Incorrect usage. Try ./a.out filename\n");
        exit(0);
    }

    FILE* file = fopen(argv[1],"r");
    if(file == NULL) 
    {
        printf("Cannot open %s \n",argv[1]);
        exit(0);
    }

    yyin = file;

    do{
        yyparse();
    }while(!feof((yyin)));

    fclose(file);
}
